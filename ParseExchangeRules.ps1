<#
.SYNOPSIS
Версионирование правил обмена 1С

.LINK
https://github.com/bf0rce/ExchangeRules1C

.DESCRIPTION
Скрипт для разбора xml-файла Правил обмена 1С на мелкие фрагменты, что позволяет версионировать их, например, в Git.

.EXAMPLE
.\ParseExchangeRules.ps1

.EXAMPLE
.\ParseExchangeRules.ps1 -Verbose

.NOTES
Вызов функций в виде "MyFunc -Par1 Value1 -Par2 Value2" принципиален. Только в таком случае параметры корректно 
передаются в функцию, могут быть изменены в ней и возвращены обратно в измененном состоянии.
#>

[CmdletBinding()]
Param(
)

function ЗаписатьКлючевыеСвойстваПравилОбмена() {
	
	$ДочерниеЭлементы = $ОбщийФайлПравил.documentElement.selectNodes("*")
	
	foreach ($Элемент in $ДочерниеЭлементы) {
		
		if ( ЭлементСодержитПрограммныйКод($Элемент) ) {
			ЗаписатьПрограммныйКод -Элемент $Элемент -ИсходныйКаталог $КаталогИсходныхКодов
		}
		
		if ( ЭлементЯвляетсяКоллекцией($Элемент) ) {
			Write-Host "  - $($Элемент.nodeName)"
			РазобратьКоллекциюОбъектов -ИсходныйЭлемент $Элемент -ИсходныйКаталог $КаталогИсходныхКодов;
		}
		
		ОчиститьЗначенияСлужебныхЭлементов -Элемент $Элемент
		
	}
	
	$ОбщийФайлПравил.save( (Join-Path -Path $КаталогИсходныхКодов -ChildPath "ПравилаОбмена.xml") )
	
}

function РазобратьКоллекциюОбъектов($ИсходныйЭлемент, $ИсходныйКаталог) {
	
	if ( $ИсходныйЭлемент.hasChildNodes() -eq $false ) {
		return
	}
	
	if ( $ИсходныйЭлемент.nodeName -eq "Группа" `
		-or $ИсходныйЭлемент.nodeName -eq "Правило" ) {
		
		$ПутьКИмениЭлементаКоллекции = "Код"
		$КаталогКоллекции = Join-Path $ИсходныйКаталог $ИсходныйЭлемент.SelectSingleNode($ПутьКИмениЭлементаКоллекции).text
	}
	elseif ( $ИсходныйЭлемент.nodeName -eq "Свойство" `
		-or $ИсходныйЭлемент.nodeName -eq "Значение" ) {
		
		$ПутьКИмениЭлементаКоллекции = "Код"
		$КаталогКоллекции = Join-Path $ИсходныйКаталог $ИсходныйЭлемент.SelectSingleNode("Код").text
	}
	elseif ( $ИсходныйЭлемент.nodeName -eq "Алгоритмы" `
		-or $ИсходныйЭлемент.nodeName -eq "Запросы" `
		-or $ИсходныйЭлемент.nodeName -eq "Параметры" ) {
		
		$ПутьКИмениЭлементаКоллекции = "@Имя"
		$КаталогКоллекции = Join-Path $ИсходныйКаталог $ИсходныйЭлемент.nodeName
	}
	elseif ( $ИсходныйЭлемент.nodeName -eq "Алгоритм" `
		-or $ИсходныйЭлемент.nodeName -eq "Запрос" `
		-or $ИсходныйЭлемент.nodeName -eq "Параметр" ) {
		
		$ПутьКИмениЭлементаКоллекции = "@Имя"
		$КаталогКоллекции = Join-Path $ИсходныйКаталог $ИсходныйЭлемент.SelectSingleNode($ПутьКИмениЭлементаКоллекции).text
	}	
	else {
		$КаталогКоллекции = Join-Path $ИсходныйКаталог $ИсходныйЭлемент.nodeName
		$ПутьКИмениЭлементаКоллекции = ""
	}
	
	[void](New-Item -ItemType Directory -Force -Path $КаталогКоллекции)
	
	$ДочерниеЭлементы = $ИсходныйЭлемент.selectNodes("*")
	foreach ( $Элемент in $ДочерниеЭлементы ) {
		
		if ( ЭлементСодержитПрограммныйКод($Элемент) ) {
			ЗаписатьПрограммныйКод -Элемент $Элемент -ИсходныйКаталог $КаталогКоллекции
		}
		
		if ( ЭлементСодержитДанныеИлиДочерниеКоллекции($Элемент.nodeName) ) {
			if ( СоздаватьКаталогДляКоллекцииЭлементов($Элемент.nodeName) ) {
				РазобратьКоллекциюОбъектов -ИсходныйЭлемент $Элемент -ИсходныйКаталог (Join-Path $КаталогКоллекции $Элемент.nodeName)
			}
			else {
				РазобратьКоллекциюОбъектов -ИсходныйЭлемент $Элемент -ИсходныйКаталог $КаталогКоллекции
			}
		}
		
		if ( ЭлементЗаписываетсяОтдельно($Элемент) ) {
			$ИмяЭлементаКоллекции = $Элемент.SelectSingleNode($ПутьКИмениЭлементаКоллекции).text
			ЗаписатьЭлементВФайл -Элемент $Элемент -ИмяФайла (Join-Path $КаталогКоллекции "$ИмяЭлементаКоллекции.xml")
		}
		
		if ( ЭлементЯвляетсяКоллекцией($Элемент) ) {
			РазобратьКоллекциюОбъектов -ИсходныйЭлемент $Элемент -ИсходныйКаталог $КаталогКоллекции
		}
		
	}
	
	if ( $ИсходныйЭлемент.hasChildNodes() -eq $false ) {
		return
	}
	
	$ЭлементКоллекции = $ИсходныйЭлемент.SelectSingleNode($ПутьКИмениЭлементаКоллекции)
	ЗаписатьЭлементВФайл -Элемент $ИсходныйЭлемент -ИмяФайла (Join-Path $ИсходныйКаталог "$($ЭлементКоллекции.text).xml")
	
}

function ЗаписатьПрограммныйКод($Элемент, $ИсходныйКаталог) {
	
	$ИмяФайла = Join-Path -Path $ИсходныйКаталог -ChildPath "Ext\$($Элемент.nodeName).bsl"
	[void](New-Item -ItemType File -Force -Path $ИмяФайла)
	
	Write-Verbose "Запись программного кода в файл '$ИмяФайла'"
	$Элемент.text | Out-File -FilePath $ИмяФайла -Encoding utf8
	$Элемент.text = ""
	
}

function ЗаписатьЭлементВФайл($Элемент, $ИмяФайла) {
	
	Write-Verbose "Запись xml-фрагмента в файл '$ИмяФайла'"
	$ЭлементыКоллекции = New-Object -ComObject MSXML2.DOMDocument.6.0
	$ЭлементыКоллекции.async = $false
	[void]$ЭлементыКоллекции.appendChild($Элемент)
	$ЭлементыКоллекции.save($ИмяФайла)
	
}

function ЭлементСодержитПрограммныйКод($Элемент) {
	
	$СписокЭлементов = @{}
	
	# Обработчики Правил конвертации объектов
	$СписокЭлементов["ПередВыгрузкой"] = ""
	$СписокЭлементов["ПриВыгрузке"] = ""
	$СписокЭлементов["ПослеВыгрузки"] = ""
	$СписокЭлементов["ПослеВыгрузкиВФайл"] = ""
	$СписокЭлементов["ПоследовательностьПолейПоиска"] = ""		
	$СписокЭлементов["ПередЗагрузкой"] = ""
	$СписокЭлементов["ПриЗагрузке"] = ""
	$СписокЭлементов["ПослеЗагрузки"] = ""
	
	# Обработчики Правил выгрузки данных
	$СписокЭлементов["ПередОбработкойПравила"] = ""
	$СписокЭлементов["ПередВыгрузкойОбъекта"] = ""
	$СписокЭлементов["ПослеВыгрузкиОбъекта"] = ""
	$СписокЭлементов["ПослеОбработкиПравила"] = ""
	
	# Обработчики Правил очистки данных
	$СписокЭлементов["ПередОбработкойПравила"] = ""
	$СписокЭлементов["ПередУдалениемОбъекта"] = ""
	$СписокЭлементов["ПослеОбработкиПравила"] = ""
	
	# Текстовое поле алгоритма и запроса
	$СписокЭлементов["Текст"] = ""
	
	# Обработчики Конвертации
	$СписокЭлементов["ПослеЗагрузкиПравилОбмена"] = ""
	$СписокЭлементов["ПередВыгрузкойДанных"] = ""
	$СписокЭлементов["ПередПолучениемИзмененныхОбъектов"] = ""
	$СписокЭлементов["ПередВыгрузкойОбъекта"] = ""
	$СписокЭлементов["ПередОтправкойИнформацииОбУдалении"] = ""
	$СписокЭлементов["ПередКонвертациейОбъекта"] = ""
	$СписокЭлементов["ПослеВыгрузкиОбъекта"] = ""
	$СписокЭлементов["ПослеВыгрузкиДанных"] = ""
	$СписокЭлементов["ПередЗагрузкойДанных"] = ""
	$СписокЭлементов["ПослеЗагрузкиПараметров"] = ""
	$СписокЭлементов["ПослеПолученияИнформацииОбУзлахОбмена"] = ""
	$СписокЭлементов["ПередЗагрузкойОбъекта"] = ""
	$СписокЭлементов["ПриПолученииИнформацииОбУдалении"] = ""
	$СписокЭлементов["ПослеЗагрузкиОбъекта"] = ""
	$СписокЭлементов["ПослеЗагрузкиДанных"] = ""
	
	# Обработчики Параметров
	$СписокЭлементов["ПослеЗагрузкиПараметра"] = ""
	
	return $null -ne $СписокЭлементов[$Элемент.nodeName]
	
}

function ЭлементЯвляетсяКоллекцией($Элемент) {
	
	$СписокЭлементов = @{}
	
	# Имена элементов-коллекций конревых элементов: Ключ - имя элемента коллекции, Значение - допустимые имена родителельских элементов
	$СписокЭлементов["Параметры"] = "ПравилаОбмена"
	$СписокЭлементов["Обработки"] = ""
	$СписокЭлементов["ПравилаКонвертацииОбъектов"] = ""
	$СписокЭлементов["ПравилаВыгрузкиДанных"] = ""
	$СписокЭлементов["ПравилаОчисткиДанных"] = ""
	$СписокЭлементов["Алгоритмы"] = ""
	$СписокЭлементов["Запросы"] = ""
	
	# Имена элементов-коллекций внутри Правил
	$СписокЭлементов["Свойства"] = ""
	$СписокЭлементов["Значения"] = ""
	
	if ( $null -eq $СписокЭлементов[$Элемент.nodeName]) {
		return $false
	}
	elseif ( $СписокЭлементов[$Элемент.nodeName] -eq "" ) {
		return $true
	}
	elseif ( $СписокЭлементов[$Элемент.nodeName] -match $Элемент.parentNode.nodeName ) {
		return $true
	}
	
	return $false
	
}

function ЭлементСодержитДанныеИлиДочерниеКоллекции($ИмяСвойства) {
	
	$СписокЭлементов = @{}
	
	# Имена элементов-коллекций внутри Правил
	$СписокЭлементов["Группа"] = ""
	$СписокЭлементов["Правило"] = ""
	$СписокЭлементов["Свойство"] = ""
	$СписокЭлементов["Значение"] = ""
	
	$СписокЭлементов["Алгоритм"] = ""
	$СписокЭлементов["Запрос"] = ""
	
	return $null -ne $СписокЭлементов[$ИмяСвойства]
	
}

function СоздаватьКаталогДляКоллекцииЭлементов($ИмяСвойства) {
	
	$СписокЭлементов = @{}
	$СписокЭлементов["Группа"] = ""
	$СписокЭлементов["Правило"] = ""
	
	return $null -ne $СписокЭлементов[$ИмяСвойства]
	
}

function ЭлементЗаписываетсяОтдельно($Элемент) {
	
	$СписокЭлементов = @{}
	$СписокЭлементов["Ид"] = ""
	$СписокЭлементов["Параметр"] = ""
	
	return $null -ne $СписокЭлементов[$Элемент.nodeName]
	
}

function ОчиститьЗначенияСлужебныхЭлементов($Элемент) {
	
	$СписокЭлементов = @{}
	$СписокЭлементов["Ид"] = ""
	$СписокЭлементов["ДатаВремяСоздания"] = "0001-01-01T00:00:00"
	
	if ( $null -ne $СписокЭлементов[$Элемент.nodeName] ) {
		$Элемент.text = $СписокЭлементов[$Элемент.nodeName]
		Write-Verbose "Очищено свойство $($Элемент.nodeName)"
	}
	
}


$КаталогИсходныхКодов = Join-Path $PSScriptRoot "src"
$ФайлПравилОбмена = Join-Path $PSScriptRoot "ПравилаОбмена.xml"

Write-Host "Чтение исходного xml-файла..."
Write-Verbose "Файл: $ФайлПравилОбмена"

try {
	$ОбщийФайлПравил = New-Object -ComObject MSXML2.DOMDocument.6.0
	$ОбщийФайлПравил.async = $false
	[void]$ОбщийФайлПравил.load($ФайлПравилОбмена)
	if ( $ОбщийФайлПравил.parseError.errorCode -ne 0 ) { throw $ОбщийФайлПравил.parseError.reason }
} catch {
	Write-Warning "Файл правил обмена не загружен: $ФайлПравилОбмена"
	Write-Warning $_
	exit
}

Write-Host "Очистка каталога исходных кодов..."
Get-ChildItem $КаталогИсходныхКодов | Remove-Item -Recurse -Force

Write-Host "Парсинг файла правил обмена..."
ЗаписатьКлючевыеСвойстваПравилОбмена
